# RDB. join 횟수 증가와 테이블 강한 의존성 문제 접근 전략

## 목차
1. [기존 문제점](##-기존-문제점)

2. [접근 고려 방안](##-접근-고려 방안)

   2-1. [비정규화](###-비정규화)

   2-2. [NoSQL](###-NoSQL)
3. [적절해 보이는 솔루션](##-적절해-보이는-솔루션)
4. [최종 솔루션 & 개인 의견](##-최종-솔루션-&-개인-의견)
## 기존 문제점
현재 MySQL을 고려한 RDB의 ERD 다이어그램의 구조는 다음과 같다.
![ERD_K-ING](/uploads/fc883c96b7ff77c986ee217d838f4e42/ERD_K-ING.png)
해당 구조에는 크게 세 가지 문제점이 발생한다.
- 상세 페이지 접근 시에 너무 많은 table에 접근해야 하여 성능 저하가 발생할 수 있음.
- place - content - cast의 구조의 복잡하여 데이터 참조 시 JOIN 문이 많아지고 쿼리문이 복잡해질 가능성이 높음.
- 정보에 대해서 Nullable이 발생할 가능성이 너무 크며 이러한 가능성은 JOIN 시, 문제가 될 수 있음.

ex) 장소 상세 페이지 : 장소 정보 -> 관련 콘텐츠 정보 -> 콘텐츠 북마크 여부 -> 해당 장소 관련 포스트 등

ex) 큐레이팅 리스트 상세 페이지 : 리스트 정보 -> 리스트에 담긴 장소 -> 각 장소의 간단한 정보

이와 같은 구성을 JOIN 문으로 확인하였을 때 4~5개의 table이 JOIN될 경우가 발생할 수 있다고 생각할 수 있다.

## 접근 고려 방안

위의 문제점을 해결하기 위해서는 JOIN 문의 횟수를 줄이거나 이 가능성을 제거해야 한다.
두 가지 정도를 해결방안으로 고려해볼 수 있다.

### 비정규화

#### 장점
- 미리 데이터를 결합하여 JOIN 감소
- 읽기 성능이 중요한 경우(상세 페이지 조회 등), 이미 원하는 형태의 데이터가 모여있는 캐싱 역할을 하기 때문에 빠르게 데이터를 제공.

#### 단점
- 동기화 문제
- 데이터 중복되어 업데이트 작업과 트랜잭션 관리가 복잡.

#### 비정규화 전략
- 뷰나 물리적 테이블 생성 : 자주 사용하는 JOIN 결과를 미리 저장하는 테이블을 생성하여 데이터 변경이 일어날 때마다 백그라운드 작업 혹은 트리거를 통해 갱신
- 캐시 계층 활용 : Redis 같은 인메모리 데이터 저장소에 조회 결과를 캐싱 후, 빈번한 조회 시 사용
- 부분 비정규화 : 모든 정보를 다 중첩 저장하기보다는, 자주 조회되는 데이터만 추가하여 JOIN 횟수를 줄임.

### NoSQL

#### 장점
- 다양한 형태의 데이터를 유연하게 저장(place-content-cast)
- 대용량 트래픽이나 복잡한 조회를 분산 시스템으로 처리하기 용이.
- 복잡한 조인 대신 중첩된 데이터 모델 : NoSQL 문서형 데이터베이스(MongoDB 등)에서는 한 문서 내에 관련 데이터를 중첩하여 함께 저장 가능.

#### 단점
- 복잡한 트랜잭션 관리가 필요한 경우 RDBMS보다 제약
- 비정규화와 유사하게 데이터 중복이 발생 가능. 데이터 일관성 유지 어려움.
- NoSQL은 조인이나 복잡한 쿼리 처리가 제한적일 수 있기 때문에 모델링 설계에 유의.

#### NoSQL 전략
- 문서형 DB (예: MongoDB) : 중첩 기능을 사용하여 예를 들면, 장소 상세 페이지의 경우에는 장소를 하나의 문서에 담고 관련 콘텐츠 및 포스트, 북마크 여부 등을 중첩 필드로 저장. 데이터 변경 시, 해당 문서 업데이트 또는 별도의 서비스를 통해 동기화.
- 키-밸류 스토어 및 캐싱 : Redis를 활용하여 빠른 읽기가 필요한 조회 결과를 캐싱
- 검색/집계 작업 : Elasticsearch와 같은 검색엔진을 별도로 사용하기 때문에 이를 통해 복잡한 검색 및 집계를 수행하고 결과를 문서형 DB 페이지에 통합할 수도 있음.
- content-cast-place 관계 문제 : 중첩 문서로 저장할 수 있고 데이터 업데이트의 빈도가 낮고 읽기가 많은 경우 효율적이며, 일관성 문제가 크지 않으면 이러한 중첩 구조가 JOIN을 대체 가능.

## 적절해 보이는 솔루션

결과적으로 두 가지 모두 읽기 전략을 중심으로 해결하는 것이 좋으며 데이터 업데이트 시에는 트리거나 정기적 배치 작업으로 데이터를 갱신하여 관리하는 솔루션들이다.

읽기 성능과 확장성이 중요한 경우, JOIN 없이 빠른 조회가 가능하기 때문에 NoSQL이 유리하다. 특히, 복합 관계(content-place-place)에 대해 여러 관계로 Join하지 않고 정해진 양식으로 읽기 부하가 높은 상태이기 때문에 NoSQL이 이 부분에서는 좋아보인다.

트랜잭션 관리와 데이터 일관성이 중요한 경우에는 비정규화를 사용하는 것이 좋다고 한다. materialized view나 자주 데이터를 비정규화하는 방식도 괜찮아 보인다.

### RDBMS + NoSQL 통한 개선
- 사용자별 맞춤 콘텐츠 페이지에서 한 번의 document 조회로 필요한 모든 정보를 가져와 응답 속도를 극대화할 수 있음.
- NoSQL 자체가 Facebook의 일부 뉴스피드, 콘텐츠 추천 시스템 등에 쓰임.
-캐스트나 장소 정보가 변경될 때, 여러 중첩 데이터들을 업데이트해야하므로 업데이트 주기와 동기화 전략(예: 배치 업데이트, 이벤트 기반 동기화) 고려 필수
- 한 문서에 너무 많은 데이터를 중첩시키면 document 크기가 커져 읽기나 업데이트 비용이 증가할 수 있기 때문에 필요 범위 내에서만 중첩.
- MongoDB 사용시, 복합 인덱스와 aggregation pipline을 제공하므로, 검색과 집계 요구가 있다면 이를 고려한 설계가 필요.


## 최종 솔루션 & 개인 의견
### 고려 상황
#### 큐레이팅 SNS 성격 웹앱
- 사용자별 피드나 상세 페이지에서 여러 테이블을 JOIN해 가져오는 경우가 빈번.
- 최신 정보(영화, 드라마, 쇼 정보)를 반영해야 하며, 데이터 업데이트는 외부 API나 크롤링으로 이루어짐.

### 전략
#### 기존 테이블 RDBMS 유지지
RDBMS 자체는 원본 데이터 저장 및 트랜잭션 관리에 용이하기 때문에 API로 데이터를 가져오거나 크롤링 데이터의 원본으로 관리할 때 적합하다.
- users : 사용자 계정, 인증, 권한 정보 등은 트랜잭션과 일관성이 필수.
- places, contents, cast : 외부 API나 크롤링으로 원본 데이터를 유지하면서 나중에 읽기용 모델을 MongDB에 사용하는 것이 좋다.
- posts, post_images, comments, likes, favorites : 사용사 생성 컨텐츠는 트랜잭션, 데이터 정합성 및 다양한 상태 관리를 위해 RDBMS로 관리하는 것이 일반적이다.
- curation_lists, curation_list_items, curation_list_bookmarks : 큐레이팅 리스트 및 사용자 아카이브와 같이 여러 사용자가 관계를 맺으며 업데이트되는 데이터는 원본 저장소로 RDBMS 유지.
#### 원본 RDBMS에 있는 content-place-cast 관계 테이블 유지
- 데이터 무결성과 업데이트, 관계 관리 측명에서 중요한 역할을 함.

#### MongoDB(문서형 DB) 기반의 읽기 최적화 모델 도입
사용자에게 빠른 조회가 필요한 상세페이지 및 복합 데이터는 여러 테이블의 정보를 결합해야하므로 이를 미리 비정규화한 문서로 만들어 빠른 조회 응답을 제공.
- content-cast-place 통합 문서 : 외부 데이터원(RDBMS)에서 콘텐츠, 캐스트, 장소 데이터를 수집한 후 하나의 도큐먼트로 구성.
- 리스트 조회용 정리 문서 : 일부 정보를 조회하여 리스트에 보여줄 경우. 예를 들어 `최신 콘텐츠` 리스트의 경우, 각 콘텐츠에 대한 간략한 정보를 문서에 넣어 조회
- 검색 결과와 연계하는 상세 데이터 : ElasticSearch에서 키워드 검색 결과로 콘텐츠 ID를 받은 후, MongoDB에서 해당 콘텐츠 도큐먼트를 가져오는 구조로 구성하면, 상세 정보 제공 시 JOIN 없이 한 번의 조회가 가능.

#### 동기화 및 데이터 파이프라인 구성
- 원본 시스템(RDBMS)와 최적화 읽기 모델(MongoDB) 사이에는 데이터 동기화 파이프라인을 구축해야 한다. 
- 외부 API/크롤링으로 주기적으로 업데이트 되는 원본 데이터가 RDBMS에 저장되면, 이를 정기적으로 MongoDB 도큐먼트로재구성하여 최신 상태를 반영.

### 개인 의견
비정형 데이터(NoSQL)을 사용하는 방법과 Materialized View를 만들어서 기존 데이터의 캐싱 형태로 사용하는 것이 좋아보인다. 이는 RDBMS의 장점인 관계성을 유지하면서도 읽기 성능을 높이기 위해 따로 저장하는 두 가지 방법이다.
View를 사용하는 것보다는 MongoDB를 사용하는 것이 더 제공하는 기능면에서나 document로 저장해두는 방식에 이점이 있고 NoSQL을 한번쯤 사용해보고 싶었던 면에서는 좋아보이지만 인프라 면에서 MongoDB를 올리고 각 MySQL과 MongoDB 간의 파이프라인을 형성하여 업데이트 트리거나 배치를 둬야하는 즉, Kafka 같은 새로운 스택을 사용해야 할꺼 같기 때문에 이 점을 인프라 개발자와 이야기해보고 결정하는 것이 좋아보인다.
