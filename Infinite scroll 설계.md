# Infinite Scroll(무한 스크롤) 설계

## 목적
- 무한 스크롤의 애니메이션/부드러운 스크롤 연출

## 방법

### Pagination(BE)
- 페이지 번호를 요청 시, 페이지 당 고정된 갯수를 반환.
- 명시적인 경계가 있기에 연속 스크롤 느낌 제공 어려움.

### Slice & Cursor(BE)
- 마지막으로 불러온 데이터의 위치를 기준으로 다음 데이터를 가져옴.
- 데이터베이스에서는 일반적으로 offset 혹은 "커서 기반 페이징" 사용, 클라이언트는 마지막 항목의 고유 값을 반환하여, 이 값을 기준으로 다음 데이터를 요청
- 새로운 데이터가 삽입되거나 삭제되어도 "커서"를 기반으로 하기 때문에 중복이나 누락 발생 가능성 적음.
- 스크롤 시 부드러운 연속성 연출 가능.

#### 작동 방식
1. 클라이언트가 데이터를 최초로 요청할 때는 커서를 생략하고 서버는 가장 최신 데이터 또는 특정 기준으로 정렬된 첫 번째 데이터 집합을 반환합니다. 이와 함께 클라이언트에 "다음 요청 시 사용할 커서"도 반환.
2. 클라이언트는 이전 응답에서 받은 커서를 포함하여 추가 데이터를 요청. 서버는 해당 커서 이후의 데이터를 찾아 반환하고, 다시 새로운 커서를 함께 제공.
3. 사용자가 계속 스크롤하거나 더 많은 데이터를 요청하면, 클라이언트는 계속 업데이트된 커서를 이용하여 추가 데이터를 요청.
```http
GET /api/posts?cursor=20251020235959_1234&limit=20
```

#### 구현 시 고려사항
- 정렬 기준 : 데이터를 어떤 순서를 기준으로 정렬할지.
- 커서의 불투명성 : 클라이언트가 내부 구현 세부사항을 알 수 없도록 커서 값을 암호화하거나 인코딩.
- 데이터 일관성 : 데이터베이스에서 데이터가 추가되거나 삭제되면 커서는 "마지막으로 본 데이터"의 위치를 기준으로 하기 때문에 추가된 데이터가 상단에 노출되어도 기존 페이지에서는 문제 없이 동작하지만 사용자 경험 측면에서 "새로운 데이터 알림"같은 별도의 UX를 고려할 수 있음.
- 클라이언트와 서버의 동기화 : 클라이언트는 각 요청마다 받은 커서를 저장하고, 다음 요청 시 올바르게 전달해야 함. 또한 잘못된 커서 값이나 만료된 커서에 대한 처리를 서버와 클라이언트 양쪽에서 구현해야 함.
- 성능 : 커서로 사용할 필드에 인덱스를 설정하면 쿼리 성능 개선 가능.

### Infinite Loading with Intersection Obeserver(FE)
- 브라우저에서 특정 요소가 뷰포트(화면)에 진입하는지 감지하는 기능을 제공.
- 사용자가 스크롤하여 페이지 하단에 도달할 때 자동으로 다음 데이터를 요청하도록 구현
- 자연스러운 스크롤 페이지를 제공하며 스크롤 이벤트를 매번 체크하지 않아 성능면에서 유리함.

## 큐레이팅 SNS에서의 설계
- 큐레이팅 SNS와 같은 웹앱에서는 사용자 경험과 데이터 일관성, 그리고 실시간 업데이트에 대한 요구가 높음.
- **커서 기반 API 설계와 Intersection Observer**를 활용한 무한 로딩 방식이 많이 쓰임

